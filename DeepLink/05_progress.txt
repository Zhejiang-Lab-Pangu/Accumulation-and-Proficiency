可执行文件的装载与进程


1. 进程虚拟地址空间
1.1 每个程序运行起来后，将拥有自己独立的虚拟地址空间（Virtual Adress Space），此空间大小由CPU的位数决定；硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，如:
    (1) 32位硬件平台决定了虚拟地址空间的地址为 0 ～ 2^32-1，即0x00000000 ~0xFFFFFFFF，即我们常说的4GB虚拟空间大小;
    (2) 64位硬件平台具有64位寻址能力，其虚拟地址空间大小达到了 2^64 byte，总共17 179 869 184 GB;
    (3) 可通过C语言的指针大小来判断虚拟空间的大小：指针大小的位数与虚拟空间的位数相同，即32位平台指针大小32bit，即4字节；64位平台指针大小64bit，即8字节。
1.2 进程的虚拟地址空间均在操作系统的掌握之中，进程只能使用那些操作系统分配给进程的地址，若访问未经允许的空间，操作系统就会捕获这些访问，将进程的这种访问当作非法操作，强制结束进程。（如‘Segmentation fault’）


2. 装载的方式
    动态装入的基本原理：程序运行是有局部性原理的，将程序最常用的部分驻留在内存中，将一些不常用的数据放在磁盘里面。动态装载方法有：覆盖装入（Overlay）和 页映射（Paging）。
2.1 覆盖装入 （无虚拟内存之前的方法）
2.2 页映射（Paging）
    (1) 页映射是虚拟存储机制的一部分。页映射是将内存和所有磁盘中的数据和指令按照“页”为单位划分成若干个页，后续所有的装载和操作的基本单位就是页。


3. 从操作系统角度看可执行文件的装载
3.1 进程的建立
    创建一个进程，然后装载相应的可执行文件并执行。在有虚拟存储的情况下，需要经历3个过程：
    (1) 创建一个独立的虚拟地址空间；
        一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，创建一个虚拟空间实际上不是创建空间，而是创建映射函数所需要的相应的数据结构；
    (2) 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系：
        可执行文件和虚拟空间的映射关系是保存在操作系统内部的一个数据结构。Linux将进程虚拟空间中的一个可执行文件段的存放区域叫做 虚拟内存区域(VMA)， Windows上叫 虚拟段(Virtual Section).
    (3) 将cpu的指令寄存器设置成可执行文件的入口地址，启动执行：
        操作系统通过设置CPU的指令寄存器将控制权交给进程，开始执行。
3.2 页错误
    当CPU开始打算执行某个地址的指令时，发现页面是空页面，此时CPU就认为这是一个页错误。CPU将控制权交给操作系统，操作系统由专门的页错误处理例程来处理这种情况。
    此时，操作系统将查询可执行文件和虚拟空间映射关系的数据结构，然后找到空页所在的VMA，计算出相应的页面在可执行文件中的偏移，再在物理内存中分配一个物理页面，建立进程中该虚拟页与分配的物理页之间映射关系，随后把CPU控制权还给进程，进程从刚才也错误位置重新开始执行。
    随着进程的执行，页错误不断产生，操作系统会为进程分配相应的物理页来满足进程的需求；若进程所需的内存超过可用的内存数量(特别是多个进程同时执行时)，此时操作系统需要精心组织和分配物理内存，甚至会收回以分配给进程的内存，更多细节参考操作系统的虚拟内存管理。


4. 进程虚存空间分布
4.1 ELF文件的链接视图和执行试图
    (1)
4.2 队和栈
4.3 堆的最大申请数量
4.4 段地址对齐
4.5 进程栈初始化


5. Linux内核装载ELF过程简介
