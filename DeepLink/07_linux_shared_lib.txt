Linux 共享库的组织

=================================
介绍一些常见的共享库
--------------------
1.linux-vdso.so.1是Linux内核提供的一个特殊的动态共享对象，用于实现一些系统调用的优化。
  (1) VDSO代表"Virtual Dynamically-linked Shared Object"，它是一个虚拟的动态链接共享对象，不对应真正的共享库文件;
  (2) VDSO的主要作用是提供一种用户空间的方式来访问一些内核空间中的数据和函数，而无需进行系统调用切换到内核空间。这样可以避免频繁的用户态和内核态之间的切换，从而提高系统调用的性能;
  (3) linux-vdso.so.1通常会在进程的地址空间中被映射为一个特殊的区域，而不是从磁盘上加载的共享库文件.
--------------------
2. Glibic ****
······
=================================
Linux的FHS规则:
(1) /bin：  二进制文件
(2) /boot： 引导文件
(3) /dev：  设备文件，用于与系统硬件进行通讯
(4) /etc:   配置文件，如网络配置、用户配置等
(5) /home:  用户主目录
(6) /lib:   共享库
(7) /mnt：  挂载点，用于挂载临时的文件系统，如优盘光盘等
(8) /opt:   可选软件包，通常由第三方软件包安装到此目录
(9) /proc： 进程信息，包含了系统运行时的进程信息
(10) /tmp:  临时目录，系统重启时会清空
(11) /usr： 用户程序，包含用户可执行的程序、库、头文件等
(12) /var： 变化数据，包含系统运行时产生的变化数据，如日志文件、邮件、缓存等
=================================


1. 共享库版本
1.1 共享库的ABI(Application Binary Interface)兼容主要包含：函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等；
导致C语言共享库ABI改变的行为主要包括:
    (1) 导出函数的行为发生改变；
    (2) 导出函数被删除；
    (3) 导出的数据结构发生变化；
    (4) 导出函数的接口发生变化。
1.2 共享库版本命名
    (1) 为了解决共享库的兼容性问题，有效的方案之一就是控制版本；LInux有一套规则来命名系统中的每一个共享库规定；
    (2) Linux规定规定的共享库的文件命名规则如下：libname.so.x.y.z
	a. 前缀"lib"、中间是共享库的名称和后缀".so"，最后3个数字组成版本号："x":主版本号,"y":次版本号，"z":发布版本号。
1.3 SO-NAME
    (1) Linux采用SO-NAME命名机制来记录共享库的依赖关系；每个共享库都有一个对应的"SO-NAME"，即共享库的文件名去掉主版本号和发布版本号，保留主版本号；
    (2) Linux系统中会为每个共享库在其所在的目录创建一个跟"SO-NAME"名称相同，并指向它的软链接；
    (3) 以"SO-NAME"命名建立软链的作用："SO-NAME"软链会指向目录中主版本号相同，次版本和发布版本最新的共享库；使得所有依赖该共享库的模块在编译、链接和运行时，都是用共享库的SO-NAME，而不用再细致的关注版本号。
2. 符号版本
SO-NAME不能解决此版本交会问题：即运行依赖高次版本共享库的程序碰到链接低次版本的SO-NAME会报缺少符号的错误。
2.1 基于符号的版本机制
    让每个导出和导入的符号都有一个相关联的版本，做法类似于名称修饰的方法；
2.2 Linux中的符号版本
    (1) Linux系统下共享库的符号版本机制并没有被广泛应用，主要使用共享库符号版本机制的是Glibc软件包中所提供的20多个共享库；
    (2) GCC可以使用".symver"汇编宏指令来指定符号版本，可以在GCC嵌入汇编中使用: asm(".symver add, add@VERS_1.1")
3. 共享库系统路径
3.1 Linux系统遵循FHS(File Hierarchy Standard)规则；FHS规定，一个系统中主要有3个存放共享库的位置:
    (1) /lib/，这个位置主要存放系统最关键和基础的共享库，如动态链接器、C语言运行库、数学库等；这些库主要是那些/bin和/sbin下的程序要用到库，还有系统启动时需要的库；
    (2) /usr/lib/，这个目录下主要保存的是一些非系统运行时所需要的关键性共享库，主要是一些开发时用到的共享库，这些共享库一般不会被用户的程序或shell脚本直接用到；这些目录下还包含了开发时可能会用到的静态库、目标文件等；
    (3) /usr/local/bin/，这个目录用来放置一些和操作系统本身并不十分相关的库，主要时一些第三方的应用程序的库；如/usr/local/bin/python；GNU的标准推荐第三方的程序应该默认将库安装到/usr/local/bin/下
4. 共享库查找过程
4.1 任何一个动态链接的模块所依赖的模块路径都保存在".dynamic"段里面，由DT_NEED类型的项表示；动态链接器的查找规则：若DT_NEED中保存的是绝对路径，则动态链接器按此路径去找，若DT_NEED保存的相对路径，则会在/lib、/usr/lib和/etc/ld.so.conf配置文件指定的目录中查找共享库；
4.2 若动态链接器每次查找共享库都遍历这些目录明显会很耗时，因此Linux系统中都有一个ldconfig程序，其为共享库目录下的每个共享库创建、删除、更新相应的SO-NAME，而每个SO-NAME指向正确的动态库目录；另外，ldconfig程序会将所有的SO-NAME收集起来放到/etc/ld.so.cache里面，建立SO-NAME的缓存；因此动态链接器可直接从/etc/ld.so.cache里面寻找；
4.3 若动态链接器在/etc/ld.so.cache中每找到，还会遍历/lib和/usr/lib/
5. 环境变量
5.1 LD_LIBRARY_PATH: 添加临时的动态库查找路径，添加后会首先找该环境变量指定的路径，再找上述路径；
5.2 LD_PRELOAD: 可以指定预先装载的一些共享库甚至目标文件；
5.3 LD_DEBUG: 打开动态链接器的调试功能；有"files","bindings","libs"等选项。
6. 共享库的创建和安装
6.1 共享库的创建
    (1) 创建共享库用到GCC两个最关键的参数："-shared"和"-fPIC"；
    (2) "-Wl" 参数可以直径参数传给链接器，如"-Wl,-soname,name" 可以指定输出共享库的SONAME 
    (3) "-rpath" 可指定目标程序的共享库查找路径，如"-rpath /path" 生成的可执行文件动态链接器会首先在/path路径下查找共享库； 
6.2 清除符号信息
    (1) 可以使用"strip"工具来清除掉共享库或可执行文件的所有符号信息和调试信息("strip"是binutils的一部分): strip libshj.so；
    (2) 也可使用ld的"-s"、"-S"参数，使链接器生成输出文件时就不产生符号信息；gcc可以通过"-Wl,-s"和"-Wl,-S"传递这两个参数；
    (3) 去除掉符号信息的文件会小很多，一般只有原来的一般大小。
6.3 共享库的安装
    (1) 一般情况是放到标准路径下，如/lib, /usr/lib, /usr/local/lib后，执行ldconfig；
    (2) 也可建立SONAME链接，并告诉哦编译器如何查找该共享库;建立SONAME也是用ldconfig，只不过要指定共享库目录，如ldconfig -n /shared_lib_parth
6.4 共享库构造和析构函数
    (1) GCC提供了共享库的构造函数，只要在函数声明时加"__attribute__((constructor))"的属性，即指定该函数会在共享库加载时被执行，即在程序的main之前执行；若是用dlopen()打开共享库，共享库会在dlopen()返回之前被执行；
    (2) GCC中在函数声明时加上"__attribute__((destructor))"属性就是共享库的析构函数，该函数会在main()函数执行完毕执行(或是程序调用exit时执行)，若共享库是运行时加载，则在使用dlclose()卸载共享库，会在dlclose()之前返回;
    (3) 声明语法：
	a. void __attribute__((constructor)) init_func(void);
        b. void __attribute__((destructor)) finit_func(void);
    (4) 多个构造和析构的优先级问题：
	a. void __attribute__((constructor(4))) init_func(void);
	b. void __attribute__((constructor(5))) init_func(void);
        c. void __attribute__((destructor(5))) finit_func(void);
        d. void __attribute__((destructor(4))) finit_func(void);
	对于构造来讲，优先级数字越小越先执行(即4先5后)；对析构来讲，优先级数字越大越先执行(即5先4后)；符合先申请的资源后释放的原则。
6.5 共享库脚本
    把某些共享库通过脚本文件组合起来，从用户的角度来看这就是一个新的共享库，这个脚本称为共享库脚本，也称动态链接脚本，此链接过程是动态完成的，也就是运行时完成的。

本章小结
linux/ELF共享库版本的命名方式、共享库符号版本机制、共享库路径、查找过程、环境变量、共享库的创建与安装。

