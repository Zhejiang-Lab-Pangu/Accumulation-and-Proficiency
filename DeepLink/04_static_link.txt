
静态链接

1. 空间与地址分配
1.1 “链接器为目标文件分配地址和空间” 指两个方面：一是在输出可执行文件中的空间，二是装载后在虚拟地址中的虚拟地址空间，重点是后者。
1.2 两步链接：（1）空间地址分配；（2）符号解析与重定位
1.3 符号地址的确定：在各个段的虚拟地址确定后，链接器会计算每个符号的虚拟地址（即给每个符号加上一个偏移量）

2. 符号解析与重定位 
2.1 编译器在编译阶段对于某一个.cpp调用外部符号时，编译成的指令所使用的都是临时的假地址(如0x00000000或0xFFFFFFFC)，等到链接完成1中空间与地址分配后，可以确定所有符号的地址，然后对每个需要重定位的指令进行地址修正；
2.2 每个要重定位的ELF段都有一个重定位表，一个重定位表是ELF文件中的一个段；
2.3 readelf -s *.o  可以用来查看目标文件的符号表

3. C++相关问题
3.1 重复代码消除
(1) 在C++中，“编译单元”（Compilation Unit）是指单个源文件以及它包含的所有头文件组成的编译范围。编译单元是编译器处理的最小单位，也就是说，编译器会一次处理一个编译单元，将源代码编译成目标文件；
(2) 不同编译单元中的相同模板实例化编译后会产生重复代码，目前主流编译器消除重复代码的做法：每个模板的实例代码都单独存放在一个段中，每个段只包含一个模板实例，这样链接时链接器就能区分这些相同的模板实例段，将其合并至最后的代码段；
(3) 函数级别链接：当要用目标文件中的任一函数或变量时，不必把整个文件链接进来的一种优化方法；即让所有的函数都像模板函数一样，单独存到一个段中，当连接器必须要用到哪个函数时，就将其合并到输出文件，没用到的则抛弃；
                函数级别链接会很大程度上减小输出文件的长度，单此优化选项会减慢编译和链接过程，因为连接器需要计算各个函数之间的依赖关系。
3.2 全局构造与析构
(1) C++的全局对象的构造函数在main之前执行，C++的全局对象的析构函数在main之后执行；
(2) Linux系统下一半程序的入口是“_start”，这个函数是Linux系统库(Glibc)的一部分，当我们的程序与Glibc库链接在一起形成最终可执行文件后，这个函数就是程序的初始化部分的入口，程序初始化部分完成一系列初始化过程之后，
    会调用main函数来执行程序的主体；main函数执行完后，返回到初始化部分，进行一些清理工作，进程结束。
(3) ELF文件中两种特殊的段：.init 和 .fini
    a. .init段里保存的是可执行指令，构成了进程的初始化代码，因此当程序开始运行时，在main函数调用之前，Glibc的初始化部分安排执行这个段中的代码；
    b. .fini段里保存的是进城终止代码指令，因此当程序main函数正常退出是，Glibc会安排执行这个段中的代码。
3.3 C++与ABI
(1) ABI(Application Binary Interface)和API(Application Programming Interface)：API一般指应用程序源码级别的接口；ABI指应用程序二进制层面的接口，兼容程度更严格；

4. 静态库链接
(1) 一种语言的开发环境会附带有语言库(Launguage Library)，这就是对操作系统的API的包装，供高级语言调用；
(2) 一个静态库可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件；
(3) 静态运行库里面一个目标文件只包含一个函数，如/usr/lib/libc.a里面printf.o文件中只有printf()函数，这么做的原因是”函数级别链接“

5.链接过程控制
(1) 控制链接过程：控制输入elf中的段如何变成输出elf可执行文件的段；
