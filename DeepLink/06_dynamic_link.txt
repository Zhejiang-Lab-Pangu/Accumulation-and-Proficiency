动态链接

1. 为什么要动态链接
1.1 内存和磁盘空间
    在静态链接情况下，多个可执行文件链接相同的模块(如目标文件)时。在磁盘和内存中都需要相同的副本，造成很大的空间浪费。
1.2 程序开发和发布
    若程序的可执行文件所需的一个目标文件更新，则需要重新链接，形成新的可执行文件，再发布给用户。
1.3 动态链接
    (1) 动态链接基本思想：将程序的模块分割开来，不再静态的链接在一起，即不对那些组成程序的目标文件进行链接，等到程序运行时才进行链接。也即：把链接这个过程推迟到了运行时再进行。
    (2) 动态链接会在内存中只有一个共享的目标文件，不会存在多个副本；那么在磁盘中存储的也是链接前的目标文件，共享目标文件也只用存储一份即可，需要时加载至内存即可。
    (3) 在内存中共享一个目标文件模块的好处：不仅可以节省内存，还可以减少物理页面的换入换出，也可以增加CPU的缓存命中率，因为不同进程的数据和指令访问都集中在同一个共享模块上。
1.4 程序可扩展性和兼容性
    (1) 程序的插件：动态链接时程序在运行时可以动态地选择加载各种程序模块，这个优点被用来制作程序的插件；
    (2) 操作系统所提供的动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台之间依赖的差异性。
1.5 动态链接的基本实现
    (1) 动态链接的基本思想是吧程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完成的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。
    (2) Linux系统中，ELF动态链接文件被称为动态共享对象(DSO)，简称共享对象，一般以“.so”为扩展名；Windows系统中，动态链接文件被称为动态链接库(DLL)，一般以“.dll”为扩展名。
    (3) Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保存在“/lib”目录下，名为“libc.so”；整个系统只保留了一份C语言库的动态链接文件“libc.so”，所有C语言编写的、动态链接的程序都可以在运行时使用它；
        具体地：当程序装载时，系统的动态链接器会将程序所需要的所有动态链接库(最基本的就是libc.so)装载到进程的地址空间，并将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。
    (4) 动态链接器是把链接过程从原来的程序装载前推迟到了装载的时候；动态链接的确会导致程序在性能上的一些损失，但动态链接的链接过程可以进行优化(如延迟绑定等方法)，可尽可能的减少性能损失。

2. 简单的动态链接例子
    2.1 将Lib.c文件编译成共享对象文件：gcc -fPIC -shared -o lib.so Lib.c    其中，-shared 表示产生共享对象
    2.2 模块(Module) 
        (1) 静态链接时，整个程序最终只有一个可执行文件，它是一个不可分割的整体；
        (2) 动态链接时，一个程序被分成若干文件，包括程序的主要部分，即可执行文件和程序所依赖的共享对象，也可以将这些部分称为模块，即动态链接下的可执行文件和共享对象都可看作程序的一个模块。
    2.3 当链接器将目标文件链接成可执行文件时，链接器必须去定目标文件中所调用函数的性质：
        (1) 若函数是一个定义在其他静态目标模块中的函数，那么链接器按照静态链接规则对函数地址进行重定位；
        (2) 若函数是一个定义在某个动态共享对象中的函数，那么链接器会将这个符号的引用标记为一个动态链接的符号，不进行地址重定位，将此过程留到装载时再进行；
        (3) 在动态链接时仍要用到共享对象，因为其保存了完整的符号信息，链接器在解析符号时就可以知道，哪些符号是动态符号。
    2.4 动态链接程序运行时地址空间分布
        (1) Linux下的动态链接器(在/lib/ld_xxx.so)，会与普通共享对象一样被映射到进程的地址空间，在系统开始运行程序前，会先将控制权交给动态链接器，由其完成所有动态链接工作后再把控制权交还给程序，再开始执行。
        (2) 共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

3. 地址无关代码
3.1 固定装载地址的问题
    是否可以让共享对象在任意地址加载？  也即：共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。
3.2 装载时重定位
    (1) 装载时重定位：在链接时，对所有绝对地址的引用不作重定位，而是推迟到装载时再完成；一旦程序模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。
3.3 地址无关代码
    (1) 地址无关代码(PIC)的技术：把共享对象中需要修改的那部分指令分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本；
    (2) 共享模块中各类型的地址引用方式：
        a. 模块内部的函数调用、跳转：
            模块内部的跳转、函数调用都可以是相对地址调用，或是基于存储器的相对调用，所以这些指令是不需要进行重定位的；
        b. 模块内部数据访问
            一个模块在内存中，前面一般是若干页的代码，后面紧跟若干页的数据，这些页之间的相对位置是固定的，也即任何一条指令与其要访问的模块内部数据间的相对位置是固定的，那么只需要相对于当前指令加上固定的偏移量即可访问模块内部数据。
        注： a) esp寄存器：Stack Pointer的缩写，称为“堆栈指针”，在x86架构中，esp寄存器通常用于指向当前线程的栈顶；
            b) ecx寄存器：Count Register， “计数寄存器”，通常用于循环计数和某些特定指令。
        c.模块间数据访问
            其他模块的全局变量的地址是跟装载地址相关的，即该地址在装载时才能确定，因此需要讲这些指令放到数据段中去；ELF在数据段里面建设了一个指向这些变量的指针数组，即全局偏移表(GOT);
            当指令要访问其他模块的变量时，程序会先找到GOT，再根据GOT中变量所对应的项找到变量的目标地址；每个变量都对应一个地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，确保每个指针指向的地址正确；
            由于模块在编译时可以确定模块内部变量相对于当前指令的偏移，那么在编译时也可以确定当前指令相对于GOT的便宜，因此确定GOT的位置跟访问模块内部数据的方法是一致的，然后再根据变量地址在GOT中的偏移就可以得到变量的地址。
        d.模块间的函数调用、跳转
            GOT中相应项保存了目标函数的地址，当模块调用目标函数时，可以通过GOT中的项进行间接跳转。此种方法存在一些性能问题，ELF采用的是更为复杂和精巧的方法。
    (3) -fPIC 和 -fpic
        添加“-fPIC”参数，可使GCC产生地址无关代码；其中"-fpic"功能相同，但产生的代码要更小，而且较快，但在某些平台会有一些限制;
        PIC的so时不包含任何代码段重定位表的，“TEXTREL”表示代码段重定位表地址，因此可用 “readelf -d xxx.so | grep TEXTREL” 来判断某个so是不是PIC的。
    (4) PIC除了可用在共享对象上，也可用于可执行文件，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件(PIE)，GCC产生PIE的参数为“-fPIE”或“-fpie”。
3.4 共享模块的全局变量问题
    (1) ELF共享库在编译时，默认将定义在模块内部的全局变量当作定义在其他模块的全局变量，通过GOT来实现变量访问；当共享模块被装载时，若某个全局变量在可执行文件中有副本，则动态链接器会把相应地址指向该副本，这样该变量在运行时实际上最终只有一个实例。
    (2) 若变量在共享模块中被初始化，那么动态链接起还需要将该初始化的值复制到程序主模块中的变量副本；若该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的该变量副本。
    (3) 共享对象lib.so中定义了全局变量G，进程A、B都是用了lib.so，当进程A改变这个全局变量G的值时，进程B中的G会受影响吗？答：不会，当lib.so被两个进程加载时，数据段在每个进程中都有独立的副本。


4. 延迟绑定(PLT)
4.1
4.2
4.3
5. 动态链接相关结构
6. 动态链接的步骤和实现
7. 显示运行时链接

本章小结
