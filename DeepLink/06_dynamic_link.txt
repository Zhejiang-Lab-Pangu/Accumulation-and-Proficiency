动态链接

1. 为什么要动态链接
1.1 内存和磁盘空间
    在静态链接情况下，多个可执行文件链接相同的模块(如目标文件)时。在磁盘和内存中都需要相同的副本，造成很大的空间浪费。
1.2 程序开发和发布
    若程序的可执行文件所需的一个目标文件更新，则需要重新链接，形成新的可执行文件，再发布给用户。
1.3 动态链接
    (1) 动态链接基本思想：将程序的模块分割开来，不再静态的链接在一起，即不对那些组成程序的目标文件进行链接，等到程序运行时才进行链接。也即：把链接这个过程推迟到了运行时再进行。
    (2) 动态链接会在内存中只有一个共享的目标文件，不会存在多个副本；那么在磁盘中存储的也是链接前的目标文件，共享目标文件也只用存储一份即可，需要时加载至内存即可。
    (3) 在内存中共享一个目标文件模块的好处：不仅可以节省内存，还可以减少物理页面的换入换出，也可以增加CPU的缓存命中率，因为不同进程的数据和指令访问都集中在同一个共享模块上。
1.4 程序可扩展性和兼容性
    (1) 程序的插件：动态链接时程序在运行时可以动态地选择加载各种程序模块，这个优点被用来制作程序的插件；
    (2) 操作系统所提供的动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台之间依赖的差异性。
1.5 动态链接的基本实现
    (1) 动态链接的基本思想是吧程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完成的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。
    (2) Linux系统中，ELF动态链接文件被称为动态共享对象(DSO)，简称共享对象，一般以“.so”为扩展名；Windows系统中，动态链接文件被称为动态链接库(DLL)，一般以“.dll”为扩展名。
    (3) Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保存在“/lib”目录下，名为“libc.so”；整个系统只保留了一份C语言库的动态链接文件“libc.so”，所有C语言编写的、动态链接的程序都可以在运行时使用它；
        具体地：当程序装载时，系统的动态链接器会将程序所需要的所有动态链接库(最基本的就是libc.so)装载到进程的地址空间，并将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。
    (4) 动态链接器是把链接过程从原来的程序装载前推迟到了装载的时候；动态链接的确会导致程序在性能上的一些损失，但动态链接的链接过程可以进行优化(如延迟绑定等方法)，可尽可能的减少性能损失。

2. 简单的动态链接例子
    2.1 将Lib.c文件编译成共享对象文件：gcc -fPIC -shared -o lib.so Lib.c    其中，-shared 表示产生共享对象
    2.2 模块(Module) 
        (1) 静态链接时，整个程序最终只有一个可执行文件，它是一个不可分割的整体；
        (2) 动态链接时，一个程序被分成若干文件，包括程序的主要部分，即可执行文件和程序所依赖的共享对象，也可以将这些部分称为模块，即动态链接下的可执行文件和共享对象都可看作程序的一个模块。
    2.3 当链接器将目标文件链接成可执行文件时，链接器必须去定目标文件中所调用函数的性质：
        (1) 若函数是一个定义在其他静态目标模块中的函数，那么链接器按照静态链接规则对函数地址进行重定位；
        (2) 若函数是一个定义在某个动态共享对象中的函数，那么链接器会将这个符号的引用标记为一个动态链接的符号，不进行地址重定位，将此过程留到装载时再进行；
        (3) 在动态链接时仍要用到共享对象，因为其保存了完整的符号信息，链接器在解析符号时就可以知道，哪些符号是动态符号。
    2.4 动态链接程序运行时地址空间分布
        (1) Linux下的动态链接器(在/lib/ld_xxx.so)，会与普通共享对象一样被映射到进程的地址空间，在系统开始运行程序前，会先将控制权交给动态链接器，由其完成所有动态链接工作后再把控制权交还给程序，再开始执行。
        (2) 共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

3. 地址无关代码
3.1 固定装载地址的问题
    是否可以让共享对象在任意地址加载？  也即：共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。
3.2 装载时重定位
    (1) 装载时重定位：在链接时，对所有绝对地址的引用不作重定位，而是推迟到装载时再完成；一旦程序模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。
3.3 地址无关代码



4. 延迟绑定(PLT)
5. 动态链接相关结构
6. 动态链接的步骤和实现
7. 显示运行时链接

本章小结
